(function() {
    const rxjs = require('rxjs');
    const _ = require('lodash');
    const serialService = require("./serial.js");            
    const Board = require("./board.js");

    class CommunicationController {

        constructor() {
            this.newBoardSubject = new rxjs.BehaviorSubject();

            this.checkSerialPorts()

            // Keeps previosuly defined sockets associated to each boardName
            this.boardSockets = {};

            // Keeps created boards, associated to boardnames (port names)
            this.boards = {};

            // We will have socket.io connection with clients on a root namespace to advertise new boards
            // and we will open namespaced sockets for each board for communication of the board activity
            this.server = require("./server.js");
            this.server.io.on('connection', (socket) => {
                // Keep track of boards that have already been published in this socket
                // in order to avoid duplicity
                const publishedBoards = {}; 

                // Notify each of the boards that has already been created
                _.each(this.boards, (board, boardName) => {
                    if (!publishedBoards[boardName]) {
                        console.log(new Date(), 'CommunicationController', 'Existing board to socket', boardName, socket.id)
                        socket.emit('board', boardName);
                        publishedBoards[boardName] = true;
                    }

                })

                this.newBoardSubject.asObservable().subscribe(board => {
                    if (board) {
                        const boardName = board.getBoardName();
                        if (!publishedBoards[boardName]) {
                            console.log(new Date(), 'CommunicationController', 'New board to socket', boardName, socket.id)                            
                            socket.emit('board', boardName);
                            publishedBoards[boardName] = true;
                        }
                    }
                })
            })
        }

        /**
         * Creates a namespaced socket for the specific board
         * 
         * @param {any} board 
         * @memberof CommunicationController
         */
        createBoardSocket(board) {
            const boardName = board.getBoardName();

            // Prepend a '/' to the boardName unless it already begins with '/'
            const nameSpace = boardName.charAt(0) === '/'
                ? boardName
                : `/${boardName}`;

            // Check if the socket already exists
            if (!this.boardSockets[boardName]) {
                const nsp = this.server.io.of(nameSpace);
                
                nsp.on('connection', (socket) => {
                    console.log("PORT CONNECTED ON THE SERVER: ", board.portName)
                    console.log(new Date(),"CONNECTED SOCKET ID: ", socket.id)
                    
                    // If this is the first socket, create an list of sockets for the board
                    this.boardSockets[boardName] = this.boardSockets[boardName] || [];
                    this.boardSockets[boardName].push(socket);
    
                    this.initialiseSocketAndBoardEvents(board, socket);
                });
            } else {
                _.each(this.boardSockets[boardName], socket => {
                    this.initialiseSocketAndBoardEvents(board, socket);
                })
            }


        }


        checkSerialPorts() {
            // LetÂ´s subscribe to new serial ports
            serialService.ports
            .subscribe(ports => {
                console.log('CommunicationController - Ports detected');
                _.each(ports, port => {
                    console.log('CommunicationController - Port', port);
                    const board = this.createNewBoard(port);
                    board.disconnected.subscribe(disconnected => {
                        if (disconnected) {
                            serialService.removePort(port);
                        }
                    })
                })
            });
        }

        removePort(board) {
            const boardName = board.getBoardName();
            serialService.removePort(boardName);
            this.boards[boardName] = null;
        }

        createNewBoard(boardName) {
            const board = new Board(boardName);
            this.boards[boardName] = board;
            this.createBoardSocket(board);
            this.newBoardSubject.next(board);

            return board;
        }

        initialiseSocketAndBoardEvents(board, socket) {
            // Clean previous listener associated to this socket
            socket.removeAllListeners();
            
            socket.on('pinMode', function(d){
                board.setPinMode(d.pin, d.mode)
            });

            socket.on('pinValue', function(d){
                board.digitalWrite(d.pin, d.value)
            });

            board.analogRead.subscribe(d => {
                socket.emit('analogRead', d);
            })

            board._digitalRead.subscribe(d => {
                socket.emit('digitalRead', d);
            })

            board._pinMode.subscribe(d => {
                if (d) { socket.emit('pinMode', d); }
            })

            board.state.subscribe(d => {
                if (d==='connected') {
                    console.log(new Date(), "BOARD CONNECTED", board.getBoardName(), socket.id)
                    socket.emit('ready', null);
                    socket.emit('pins', board.pins);
                    socket.emit('analogPins', board.analogPins);
                    socket.emit('state', 'connected');
                }

                socket.emit('state', d);
            })
        }

        init() {}

        getBoards() {
            return this.boards;
        }
    };



    const controller = new CommunicationController();

    module.exports = controller;
}());