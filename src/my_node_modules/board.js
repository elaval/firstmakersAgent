(function() {

const Firmata = require('firmata');
const rxjs = require("rxjs");
const _ = require('lodash');


class Board {
    constructor(port) {
        this.portName = port;
        this.currentState = "disconnected";

        this.newConnectionSubject = new rxjs.Subject();
        this.newConnection = this.newConnectionSubject.asObservable();
        
        this.newDataSubject = new rxjs.Subject();
        this.newData = this.newDataSubject.asObservable();

        this.analogReadSubject = new rxjs.Subject();
        this.analogRead = this.analogReadSubject.asObservable();

        this.digitalReadSubject = new rxjs.Subject();
        this._digitalRead = this.digitalReadSubject.asObservable();

        this.pinModeSubject = new rxjs.BehaviorSubject();
        this._pinMode = this.pinModeSubject.asObservable();

        this.stateSubject = new rxjs.BehaviorSubject("disconnected");
        this.state = this.stateSubject.asObservable();

        this.updateSubject = new rxjs.BehaviorSubject();
        this.update = this.updateSubject.asObservable();

        this.disconnectedSubject = new rxjs.BehaviorSubject();
        this.disconnected = this.disconnectedSubject.asObservable();

        this.previousValues = {};  // Store the previous value of a pin to detect changes

        this.connecting = false;
        this.connected = false;
        this._disconnected = false;
        this.firmataBoard = undefined;

        this.connect(port);

    }

    /**
     * Initiates a port connection
     * 
     * @param {any} port 
     * @memberof Board
     */
    connect(port) {

        this.portName = port;

        window.setTimeout(() => {
            this.currentState = "connecting";            
            this.updateSubject.next();
            this.stateSubject.next("connecting");
        },0);
        
        
        // create a new firmata board on the given port
        this.firmataBoard = new Firmata(port, (err) => {
            // Clear timeout to avoid problems if connection is closed before timeout is completed
            clearTimeout(this.connectionTimeout); 
            console.log("CLEAR TIMEOUT", port)
            
                
            if (err) {
                this.currentState = "disconnected";                
                this.updateSubject.next();
                this.stateSubject.next("disconnected");
                this.disconnect(true);
                
            } else {
                this.setDefaultPinModes(this.firmataBoard);
                this.pins = this.firmataBoard.pins;
                this.analogPins = this.firmataBoard.analogPins;
                
                this.currentState = "connected";                
                this.updateSubject.next();
                this.stateSubject.next("connected");
                
                console.log("Connected to board");

                this.firmataBoard.sp.on('disconnect', this.disconnectHandler.bind(this));
                this.firmataBoard.sp.on('close', this.closeHandler.bind(this));
                this.firmataBoard.sp.on('error', this.errorHandler.bind(this));
                this.reportAnalogPins();
                this.newConnectionSubject.next(this);


            }
        })

        // Set timeout to check if device does not speak firmata (in such case new Board callback was never called, but board object exists) 
        this.connectionTimeout = setTimeout(() => {
            console.log("TIMEOUT")
        // If !board.versionReceived, the board has not established a firmata connection
        if (this.firmataBoard && !this.firmataBoard.versionReceived) {
            var port = this.firmataBoard.sp.path;


            // silently closing the connection attempt
            this.disconnect(true); 
            this.updateSubject.next();
            this.stateSubject.next("wrong connection (firmata loaded?)");

        } else {
            this.updateSubject.next();
            this.stateSubject.next("wrong connection (firmata loaded?)");
        }

        }, 15000);

  
    }

    disconnect(silent) {
        if (this.isBoardReady()) {
            // Prevent disconnection attempts before board is actually connected
            this.connected = false;
            this.disconnecting = true;
            this.firmataBoard.sp.close();
            this.closeHandler(silent);
        } else if (!this.firmataBoard) {
            // Don't send info message if the board has been connected
            if (!silent) {
                alert('Board is not connected');
            }
        } 
    }

    isBoardReady() {
        return ((this.firmataBoard !== undefined) 
                && (this.firmataBoard.pins.length>0) 
                && (!this.disconnecting));
    };
  
    setPinMode(pinNumber, mode) {
        const pin = this.firmataBoard.pins[pinNumber];
        // Check if mode is supported by the pin
        const index = _.findIndex(pin.supportedModes, d => d === mode);
        if ( index > -1) {
            this.firmataBoard.pinMode(pinNumber,mode);
            this.pinModeSubject.next({pin: pinNumber, mode: mode});

            if (mode === this.firmataBoard.MODES.INPUT) {
                this.firmataBoard.digitalRead(pinNumber, (d) => {
                    if (d !== this.previousValues[pinNumber]) {
                        this.newDataSubject.next(this.firmataBoard.pins);                                        
                        this.digitalReadSubject.next({pin:pinNumber, value:d});
                    }
                    this.previousValues[pinNumber] = d;
                });
            }

        };
    }

    /**
     * Initiates an AnalogRead on each analog pin in order to update their values
     * 
     * @memberof Board
     */
    reportAnalogPins() {
        this.firmataBoard.analogPins.forEach((element,analogPinNumber) => {
            this.firmataBoard.analogRead(analogPinNumber, (d) => {
                const pinNumber = this.firmataBoard.analogPins[analogPinNumber]

                if (d !== this.previousValues[pinNumber]) {
                    this.newDataSubject.next(this.firmataBoard.pins);                    
                    this.analogReadSubject.next({analogPin:analogPinNumber, pin:pinNumber, value:d});
                }
                this.previousValues[pinNumber] = d;
            });
        });
    }

    digitalRead(pinNumber,callback) {
        this.firmataBoard.digitalRead(pinNumber, callback)
    }

    digitalWrite(pinNumber,value) {
        this.firmataBoard.digitalWrite(pinNumber, value)
        this.newDataSubject.next(this.firmataBoard.pins);                                        
        this.digitalReadSubject.next({'pin':pinNumber, 'value':value});
    }

    disconnectHandler() {
        console.log("disconnected", this.portName)
        this.currentState = "disconnected";        
        this.updateSubject.next();
        this.stateSubject.next("disconnected");
        this.disconnectedSubject.next(true);
    }

    closeHandler() {
        var portName =  "unknown";
        
        if (this.firmataBoard) {
            portName = this.firmataBoard.sp.path;
            
            this.firmataBoard.sp.removeListener('disconnect', this.disconnectHandler);
            this.firmataBoard.sp.removeListener('close', this.closeHandler);
            this.firmataBoard.sp.removeListener('error', this.errorHandler);
            this.firmataBoard = undefined;
        };

        this.currentState = "disconnected";        
        this.updateSubject.next();
        this.stateSubject.next("disconnected");
        
        

        // $rootScope.$broadcast("board.closed", {'port':portName, 'disconnected':this.disconnected, 'silent':silent});
        this._disconnected = false;
    }

    /**
     * sets the default pin modes for the given board to the board defaults
     * board.MODES.OUTPUT to digital pins
     * board.MODES.ANALOG to analog pins.
     * 
     * @param {any} board 
     * @memberof Board
     */
    setDefaultPinModes(board) {
        const analogPins = board.analogPins;

        board.pins.forEach( (pin, pinNumber) => {
            // Chekc if thi sis an analog pin
            if ( analogPins.indexOf(pinNumber) >= 0 ) {
                pin.mode = board.MODES.ANALOG
            } else {
                pin.mode = board.MODES.OUTPUT
            }
        })
    }

    getBoardName() {
        return this.portName;
    }

    errorHandler() {

    }

}


module.exports = Board;
}())
